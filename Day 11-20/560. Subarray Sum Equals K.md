# 560. Subarray Sum Equals K

**Difficulty:** Medium

## Topics
- Companies
- Hint

### Companies
- Facebook
- Amazon
- Google
- Microsoft
- Oracle

---

Given an array of integers `nums` and an integer `k`, return the total number of subarrays whose sum equals `k`.

A subarray is a contiguous non-empty sequence of elements within an array.

## Examples

### Example 1:

**Input:** `nums = [1,1,1]`, `k = 2`  
**Output:** `2`

### Example 2:

**Input:** `nums = [1,2,3]`, `k = 3`  
**Output:** `2`

## Constraints:

- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

## My nala code(Brute force method)

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int count = 0;
        int n = nums.size();

        // Loop to find all subarrays
        for (int i = 0; i < n; i++) {
            int sum = 0; // Reset sum for each new starting point
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum == k) {
                    count++;
                }
            }
        }

        return count; // Return the total count of subarrays
    }
};
```
To optimize the given code, we can use a hashmap (or unordered_map in C++) to store the cumulative sum up to each index. This allows us to check if a subarray with the sum `k` exists in constant time. This approach reduces the time complexity from O(n^2) to O(n).

Here's the optimized code:

```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> sumCount;
        int count = 0;
        int sum = 0;

        sumCount[0] = 1; // To handle the case when the subarray starts from index 0

        for (int num : nums) {
            sum += num;
            if (sumCount.find(sum - k) != sumCount.end()) {
                count += sumCount[sum - k];
            }
            sumCount[sum]++;
        }

        return count;
    }
};
```

### Approach, Intuition, and Logic

**Approach:**
1. Use a hashmap to store the cumulative sum up to each index.
2. Traverse through the array while maintaining the cumulative sum.
3. For each element, check if the cumulative sum minus `k` exists in the hashmap. If it does, add the frequency of that sum to the count.
4. Update the hashmap with the current cumulative sum.

**Intuition:**
- By keeping track of the cumulative sums, we can efficiently check if there exists a previous cumulative sum that, when subtracted from the current cumulative sum, equals `k`.
- This allows us to count the number of subarrays that sum to `k` in linear time.

**Logic:**
- If `sum` is the cumulative sum up to the current index and `sum - k` is a previously seen cumulative sum, it means the subarray between the previous index and the current index sums to `k`.

### Explanation

1. **Initialization:**
   - We declare an unordered_map `sumCount` to store the cumulative sums and their frequencies.
   - `count` is initialized to 0, which will hold the total number of subarrays that sum to `k`.
   - `sum` is initialized to 0, which will store the cumulative sum of the elements as we iterate through the array.
   - We set `sumCount[0] = 1` to handle the case where a subarray that starts from the beginning of the array sums to `k`.

2. **Iterate through the array:**
   - For each element `num` in `nums`, we add it to the `sum`.
   - We then check if `sum - k` exists in `sumCount`. If it does, it means there is a subarray that sums to `k`. We add the frequency of `sum - k` to `count`.
   - Finally, we update the `sumCount` map to include the current `sum`.

3. **Return the result:**
   - After iterating through the entire array, we return `count`, which holds the total number of subarrays that sum to `k`.

### Detailed Steps

**Initialization:**
   ```cpp
   unordered_map<int, int> sumCount;
   int count = 0;
   int sum = 0;
   sumCount[0] = 1; // To handle the case when the subarray starts from index 0
   ```

Certainly! This code is part of an algorithm typically used to solve problems like "finding the number of subarrays that sum up to a target value `k`." Let’s break down each part in detail.

### Problem Context:
Given an array `nums` of integers and a target value `k`, you want to find the number of contiguous subarrays that sum up to `k`.

### Variables:
- **`sum`**: This variable keeps track of the cumulative sum as you iterate through the array `nums`.
- **`count`**: This variable counts the number of subarrays that sum to `k`.
- **`sumCount`**: This is a dictionary (or `unordered_map` in C++) that keeps track of how many times each cumulative sum has been seen so far.

### Code Explanation:

#### 1. Iterating through the array:
```cpp
for (int num : nums) {
    sum += num;
```
- **`for (int num : nums)`**: This loop iterates through each number (`num`) in the array `nums`.
- **`sum += num`**: Add the current number to `sum` to update the cumulative sum up to the current position in the array.

#### 2. Checking for Subarrays that Sum to `k`:
```cpp
    if (sumCount.find(sum - k) != sumCount.end()) {
        count += sumCount[sum - k];
    }
```
- **`sum - k`**: This expression calculates what the cumulative sum would have been at a previous point if the current subarray (from that previous point to the current point) sums to `k`.

- **`sumCount.find(sum - k) != sumCount.end()`**: 
  - This checks if the difference `sum - k` exists in the dictionary `sumCount`. 
  - If it does, it means there is a previous cumulative sum that, when subtracted from the current cumulative sum, equals `k`. This implies that the subarray between that previous sum and the current sum has a sum equal to `k`.

- **`count += sumCount[sum - k];`**:
  - If the condition is true, it increments `count` by the number of times this specific cumulative sum (`sum - k`) has been seen.
  - This accounts for all subarrays ending at the current index that sum to `k`.

#### 3. Updating the Dictionary:
```cpp
    sumCount[sum]++;
}
```
- **`sumCount[sum]++`**:
  - This line updates the dictionary `sumCount` to indicate that the cumulative sum `sum` has been seen one more time.
  - If `sum` already exists in `sumCount`, it increments its count by 1. If not, it adds `sum` to the dictionary with an initial count of 1.

### Example Walkthrough:
Let’s say `nums = [1, 2, 3]` and `k = 3`. The goal is to find all subarrays that sum to 3.

1. **Initial Setup**:
   - `sum = 0`, `count = 0`, `sumCount = {0: 1}` (Starting with 0 to handle subarrays starting from index 0).

2. **First Iteration (num = 1)**:
   - `sum = 0 + 1 = 1`
   - `sum - k = 1 - 3 = -2` (not in `sumCount`, so nothing happens)
   - Update `sumCount`: `sumCount = {0: 1, 1: 1}`

3. **Second Iteration (num = 2)**:
   - `sum = 1 + 2 = 3`
   - `sum - k = 3 - 3 = 0` (0 is in `sumCount`, `count` becomes 1)
   - Update `sumCount`: `sumCount = {0: 1, 1: 1, 3: 1}`

4. **Third Iteration (num = 3)**:
   - `sum = 3 + 3 = 6`
   - `sum - k = 6 - 3 = 3` (3 is in `sumCount`, `count` becomes 2)
   - Update `sumCount`: `sumCount = {0: 1, 1: 1, 3: 1, 6: 1}`

**Final `count = 2`** because there are two subarrays that sum to `k` (i.e., `[1, 2]` and `[3]`).

### Summary:
This code efficiently finds all subarrays that sum to a given target `k` using a cumulative sum approach and a dictionary to store how often each sum has been encountered. This avoids the need for nested loops, reducing time complexity from `O(n^2)` to `O(n)`.

### Time Complexity
- **O(n)**: We iterate through the array once, performing constant time operations for each element.

### Space Complexity
- **O(n)**: In the worst case, the hashmap stores the cumulative sum at each index, requiring space proportional to the number of elements in the array.

This approach efficiently counts the number of subarrays that sum to `k` using a hashmap to keep track of cumulative sums, achieving a significant improvement in performance over the naive O(n^2) solution.
