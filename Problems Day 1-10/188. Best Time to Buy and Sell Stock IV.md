
# Problem 188: Best Time to Buy and Sell Stock IV

- Companies : Amazon, Apple, Nvidia, Google, Citadel

## Problem Summary

You are given an integer array `prices` where `prices[i]` represents the price of a given stock on day `i`. You also have an integer `k`, which is the maximum number of transactions you can make (a transaction is one "buy" followed by one "sell"). Your goal is to maximize the profit you can achieve with at most `k` transactions.

### Key Points:

- You cannot engage in multiple transactions at the same time (you must sell the stock before you can buy again).
- You want to maximize your profit by making up to `k` transactions.

### Example Scenarios

**Example 1:**

- **Input:** `k = 2`, `prices = [2, 4, 1]`
- **Output:** `2`
- **Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4). The profit is 4 - 2 = 2.

**Example 2:**

- **Input:** `k = 2`, `prices = [3, 2, 6, 5, 0, 3]`
- **Output:** `7`
- **Explanation:** 
  - Buy on day 2 (price = 2) and sell on day 3 (price = 6). Profit = 6 - 2 = 4.
  - Then buy on day 5 (price = 0) and sell on day 6 (price = 3). Profit = 3 - 0 = 3.
  - Total profit = 4 + 3 = 7.

## Approach Using Dynamic Programming

1. **If `k` is Large (i.e., Unlimited Transactions):**  
   If `k` is larger than half the number of days (`k >= prices.size() / 2`), the problem simplifies to allowing as many transactions as you want. In this case, you can just add up all the profitable price differences.

2. **Dynamic Programming Table (DP Table):**  
   We maintain a 2D table `dp[i][j]`, where:
   - `i` is the number of transactions (up to `k`).
   - `j` is the day index.

   The goal is to fill this table such that `dp[i][j]` holds the maximum profit achievable using `i` transactions by day `j`.

3. **Recurrence Relation:**  
   The relation used to update the DP table is:
   ```cpp
   dp[i][j] = max(dp[i][j-1], prices[j] + max_diff);
   ```
   Here, `max_diff` is a helper variable that keeps track of the best possible profit from previous days:
   ```cpp
   max_diff = max(max_diff, dp[i-1][j] - prices[j]);
   ```

   This relation helps decide whether to:
   - Skip the transaction on day `j` (`dp[i][j-1]`), or
   - Make a transaction by buying earlier and selling on day `j`.

## Solution

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        
        // If k is large enough, treat it as an unlimited transaction problem
        if (k >= n / 2) {
            int maxProfit = 0;
            for (int i = 1; i < n; ++i) {
                if (prices[i] > prices[i - 1]) {
                    maxProfit += prices[i] - prices[i - 1];
                }
            }
            return maxProfit;
        }
        
        // DP array to store maximum profit
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        
        for (int i = 1; i <= k; ++i) {
            int maxDiff = -prices[0];
            for (int j = 1; j < n; ++j) {
                dp[i][j] = max(dp[i][j - 1], prices[j] + maxDiff);
                maxDiff = max(maxDiff, dp[i - 1][j] - prices[j]);
            }
        }
        
        return dp[k][n - 1];
    }
};
```

### How the Code Works:

1. **Edge Case Handling:** If `k` is large enough (greater than half the number of days), treat it as an unlimited transaction problem.
2. **DP Array:** The 2D DP array `dp[i][j]` tracks the maximum profit for each transaction `i` up to day `j`.
3. **Profit Calculation:** For each transaction level `i`, the inner loop calculates the maximum profit by either skipping a transaction or making one.

### Time Complexity:
- The time complexity is `O(k * n)`, where `k` is the number of transactions and `n` is the number of days.

### Space Complexity:
- The space complexity is `O(k * n)` due to the DP table.
<details>
    <summary>You can also try</summary>

### Map usage
```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        map<int, int> freqMap; // Map to store the frequency of each element
        vector<int> v; // Vector to store duplicate elements

        // Step 1: Count the frequency of each element in the array
        for (int num : nums) {
            freqMap[num]++;
        }

        // Step 2: Identify elements that occur exactly twice
        for (auto& [num, count] : freqMap) {
            if (count == 2) {
                v.push_back(num);
            }
        }

        return v; // Return the vector of duplicates
    }
};
```

### Explanation:

1. **`map<int, int> freqMap;`**: A `map` is used to store each unique element from the `nums` vector as a key and its frequency (the number of times it appears) as the corresponding value.

2. **Counting Frequencies**:
    ```cpp
    for (int num : nums) {
        freqMap[num]++;
    }
    ```
    - This loop iterates over each element in the `nums` vector.
    - For each element, it increments the count in the `map`. If the element is encountered for the first time, it is added to the `map` with a count of 1.

3. **Finding Duplicates**:
    ```cpp
    for (auto& [num, count] : freqMap) {
        if (count == 2) {
            v.push_back(num);
        }
    }
    ```
    - This loop iterates over the `map` to check the frequency of each element.
    - If an element occurs exactly twice (i.e., `count == 2`), it is added to the result vector `v`.

4. **Return the Result**:
    - Finally, the vector `v`, which contains all the elements that appeared exactly twice, is returned.

This version using `map` is efficient and avoids the need to sort the array, making it a good alternative for finding duplicates in an unsorted array.

### unordered_map

```cpp
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        unordered_map<int, int> freqMap; // Map to store the frequency of each element
        vector<int> v; // Vector to store duplicate elements

        // Step 1: Count the frequency of each element in the array
        for (int num : nums) {
            freqMap[num]++;
        }

        // Step 2: Identify elements that occur exactly twice
        for (auto& [num, count] : freqMap) {
            if (count == 2) {
                v.push_back(num);
            }
        }

        return v; // Return the vector of duplicates
    }
};
```
